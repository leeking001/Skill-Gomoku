<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>äº”å­æ£‹ï¼šè¯¸ç¥ä¹‹æˆ˜</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&display=swap" rel="stylesheet">
    <style>
        :root {
            --wow-gold: #F8B700;
            --wow-dark: #0F1115;
            --wow-panel: #181A21;
            --wow-border: #565656;
            --log-bg: rgba(0, 0, 0, 0.6);
            --safe-bottom: env(safe-area-inset-bottom, 20px);
        }

        * { box-sizing: border-box; }

        html, body {
            margin: 0; padding: 0; width: 100%; height: 100dvh; /* å¼ºåˆ¶æ»¡å± */
            overflow: hidden; user-select: none;
            font-family: "KaiTi", "STKaiti", serif;
            background-color: #050505; color: #eee;
            display: flex; flex-direction: column; /* å‚ç›´æ’åˆ— */
            background-image: radial-gradient(circle at 50% 30%, #2a2a2a 0%, #000 80%);
        }

        /* 1. é¡¶éƒ¨æ ‡é¢˜ (å›ºå®šé«˜åº¦) */
        .header-area {
            height: 40px; display: flex; align-items: center; justify-content: center;
            width: 100%; position: relative; flex-shrink: 0;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
        }
        h1 { font-size: 22px; margin: 0; text-shadow: 0 0 10px #ff4757; letter-spacing: 2px; color: #eccc68; }
        .help-btn {
            position: absolute; right: 10px; font-size: 12px; padding: 2px 8px;
            border: 1px solid #666; border-radius: 10px; color: #aaa;
        }

        /* 2. AI é¢æ¿ (å›ºå®šé«˜åº¦) */
        .boss-frame {
            width: 94%; height: 60px; margin: 5px auto;
            display: flex; align-items: center; padding: 5px;
            background: var(--wow-panel); border: 2px solid #8C1616; border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.8); flex-shrink: 0;
        }
        .portrait {
            width: 40px; height: 40px; background: #000; border: 2px solid var(--wow-gold);
            border-radius: 4px; display: flex; align-items: center; justify-content: center;
            font-size: 24px; margin-right: 10px;
        }
        .stats { flex: 1; display: flex; flex-direction: column; justify-content: center; }
        .name { font-size: 14px; color: var(--wow-gold); font-weight: bold; line-height: 1.2; }
        .bar-container { height: 8px; background: #111; border: 1px solid #333; margin-top: 2px; position: relative; width: 100%; }
        .bar-fill { height: 100%; width: 0%; transition: width 0.4s ease-out; }
        .mana { background: linear-gradient(90deg, #0070DE, #00C0FF); }
        .rage { background: linear-gradient(90deg, #8C1616, #FF4757); }
        .bar-text { position: absolute; top: -2px; width: 100%; text-align: center; font-size: 9px; color: #fff; transform: scale(0.8); }

        /* 3. æ£‹ç›˜åŒºåŸŸ (å¼¹æ€§ä¼¸ç¼©ï¼Œæ ¸å¿ƒä¿®å¤) */
        .board-flex-container {
            flex: 1; /* å æ®æ‰€æœ‰å‰©ä½™ç©ºé—´ */
            width: 100%;
            display: flex;
            align-items: center; justify-content: center;
            position: relative;
            overflow: hidden;
            padding: 5px;
        }
        .board-wrapper {
            /* ä¿æŒæ­£æ–¹å½¢ï¼Œæœ€å¤§ä¸è¶…è¿‡å®½åº¦ï¼Œæœ€å¤§ä¸è¶…è¿‡é«˜åº¦ */
            width: 100%; max-width: 96vw; 
            aspect-ratio: 1/1; 
            max-height: 100%; /* é™åˆ¶é«˜åº¦ä¸æº¢å‡º */
            
            position: relative; padding: 4px;
            background: #252525; border: 3px solid var(--wow-gold); border-radius: 4px;
            box-shadow: 0 10px 30px rgba(0,0,0,1);
        }
        canvas { display: block; width: 100%; height: 100%; cursor: crosshair; }
        #effectLayer { position: absolute; top: 4px; left: 4px; pointer-events: none; z-index: 2; width: calc(100% - 8px); height: calc(100% - 8px); }

        /* 4. æˆ˜æ–—æ—¥å¿— (å›ºå®šé«˜åº¦) */
        .combat-log-container {
            width: 94%; height: 30px; flex-shrink: 0;
            background: var(--log-bg); border: 1px solid #444; border-radius: 4px;
            margin: 0 auto 5px auto; overflow-y: auto; padding: 2px 6px;
            font-family: sans-serif; font-size: 10px; line-height: 24px;
            box-shadow: inset 0 0 10px #000; scroll-behavior: smooth;
        }
        .log-entry { white-space: nowrap; }
        .log-p1 { color: #4cd137; } .log-p2 { color: #FF4757; } .log-skill { color: var(--wow-gold); }

        /* 5. åº•éƒ¨ç©å®¶åŒº (å›ºå®šé«˜åº¦ï¼Œé€‚é…å®‰å…¨åŒº) */
        .player-zone {
            width: 100%; flex-shrink: 0;
            display: flex; flex-direction: column; align-items: center;
            background: linear-gradient(to top, #000 0%, rgba(20,20,20,0.95) 100%);
            border-top: 1px solid #333;
            padding-bottom: calc(10px + var(--safe-bottom)); /* åº•éƒ¨å®‰å…¨åŒº */
        }
        
        .status-text {
            font-size: 12px; color: #ffd700; text-shadow: 1px 1px 2px #000;
            margin: 2px 0; text-align: center; height: 16px;
        }

        .player-frame {
            width: 94%; height: 50px; display: flex; align-items: center; flex-direction: row-reverse;
            padding: 5px; margin-bottom: 5px;
            background: var(--wow-panel); border: 2px solid #4cd137; border-radius: 4px;
        }
        .player-frame .name { text-align: right; color: #4cd137; }

        .action-bar { 
            display: grid; grid-template-columns: repeat(5, 1fr); gap: 8px; 
            padding: 0 10px; width: 96%; margin-bottom: 5px;
        }
        .skill-btn {
            aspect-ratio: 1/1; background: #222; border: 1px solid #666; border-radius: 4px;
            position: relative; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center;
            box-shadow: inset 0 0 5px #000; transition: 0.1s;
        }
        .skill-icon-text { font-size: 18px; margin-bottom: 2px; }
        .skill-name { font-size: 9px; color: #ddd; transform: scale(0.8); white-space: nowrap; }
        .cost-badge {
            position: absolute; top: -3px; right: -3px; font-family: sans-serif; font-size: 9px; color: #fff;
            background: rgba(0,0,0,0.8); padding: 1px 3px; border-radius: 3px; border: 1px solid #444;
        }
        .skill-btn:not(.ready) { filter: grayscale(100%) brightness(0.5); }
        .skill-btn.ready { border-color: #aaa; box-shadow: 0 0 5px var(--wow-gold); }
        .skill-btn.active { border-color: #FF4757; box-shadow: 0 0 10px #FF4757; animation: flash 1s infinite; }
        @keyframes flash { 0%,100% { border-color: #FF4757; } 50% { border-color: #fff; } }

        /* å¼¹çª— */
        .modal-mask { position: fixed; top:0; left:0; width:100%; height:100%; background: rgba(0,0,0,0.9); z-index: 999; display: none; align-items: center; justify-content: center; flex-direction: column; }
        .help-content { width: 80%; background: #181818; border: 1px solid #666; padding: 20px; border-radius: 8px; color: #ddd; font-size: 12px; line-height: 1.6; }
        .help-row { display: flex; justify-content: space-between; border-bottom: 1px solid #333; padding: 5px 0; }
        .result-text { font-size: 50px; color: var(--wow-gold); text-shadow: 0 0 20px #e67e22; font-weight: bold; margin-bottom: 30px; }
        .restart-btn { padding: 10px 30px; background: #8C1616; color: #fff; border: 2px solid #fff; font-size: 16px; border-radius: 4px; }

    </style>
</head>
<body>

    <div class="header-area">
        <h1>è¯¸ç¥ä¹‹æˆ˜</h1>
        <div class="help-btn" onclick="toggleHelp()">æŠ€èƒ½è¯´æ˜</div>
    </div>

    <div class="boss-frame">
        <div class="portrait">ğŸ‘¹</div>
        <div class="stats">
            <div class="name">é­”å¤´ (AI)</div>
            <div class="bar-container"><div class="bar-fill rage" id="p2-mp"></div><div class="bar-text"><span id="p2-val">0</span> / 100</div></div>
        </div>
    </div>

    <div class="board-flex-container">
        <div class="board-wrapper" id="board-wrapper">
            <canvas id="board" width="900" height="900"></canvas>
            <canvas id="effectLayer" width="900" height="900"></canvas>
        </div>
    </div>

    <div class="combat-log-container" id="combat-log">
        <div class="log-entry"><span class="log-sys">æˆ˜æ–—å¼€å§‹...</span></div>
    </div>

    <div class="player-zone">
        <div class="status-text" id="status-text">è¯·ä¾ å®¢è½å­</div>

        <div class="player-frame">
            <div class="portrait">ğŸ¥·</div>
            <div class="stats">
                <div class="name">ä¾ å®¢ (ä½ )</div>
                <div class="bar-container"><div class="bar-fill mana" id="p1-mp"></div><div class="bar-text"><span id="p1-val">0</span> / 100</div></div>
            </div>
        </div>

        <div class="action-bar">
            <div class="skill-btn" id="btn-s1" onclick="useSkill(1)"><div class="cost-badge">30</div><div class="skill-icon-text">â³</div><div class="skill-name">æ—¶å…‰å€’æµ</div></div>
            <div class="skill-btn" id="btn-s2" onclick="useSkill(2)"><div class="cost-badge">70</div><div class="skill-icon-text">ğŸŒªï¸</div><div class="skill-name">é£æ²™èµ°çŸ³</div></div>
            <div class="skill-btn" id="btn-s3" onclick="useSkill(3)"><div class="cost-badge">85</div><div class="skill-icon-text">ğŸ§Š</div><div class="skill-name">é™å¦‚æ­¢æ°´</div></div>
            <div class="skill-btn" id="btn-s4" onclick="useSkill(4)"><div class="cost-badge">55</div><div class="skill-icon-text">ğŸ’¥</div><div class="skill-name">åŠ›æ‹”å±±å…®</div></div>
            <div class="skill-btn" id="btn-s5" onclick="useSkill(5)"><div class="cost-badge">100</div><div class="skill-icon-text">â™»ï¸</div><div class="skill-name">ä¸œå±±å†èµ·</div></div>
        </div>
    </div>

    <div class="modal-mask" id="helpModal" onclick="toggleHelp()">
        <div class="help-content" onclick="event.stopPropagation()">
            <h3 style="color:#eccc68; margin-top:0; text-align:center">æŠ€èƒ½æ‰‹å†Œ</h3>
            <div class="help-row"><span style="color:#9b59b6">æ—¶å…‰å€’æµ (30)</span><span>æ‚”æ£‹ä¸€æ­¥</span></div>
            <div class="help-row"><span style="color:#e74c3c">åŠ›æ‹”å±±å…® (55)</span><span>ç‚¸æ¯åå­—èŒƒå›´</span></div>
            <div class="help-row"><span style="color:#e67e22">é£æ²™èµ°çŸ³ (70)</span><span>ç§»åŠ¨æ•Œå­</span></div>
            <div class="help-row"><span style="color:#3498db">é™å¦‚æ­¢æ°´ (85)</span><span>é¢å¤–å›åˆ</span></div>
            <div class="help-row"><span style="color:#f1c40f">ä¸œå±±å†èµ· (100)</span><span>é‡ç½®æ£‹å±€</span></div>
            <p style="color:#aaa; text-align:center; margin-bottom:0; margin-top:10px;">ç‚¹å‡»ä»»æ„å¤„å…³é—­</p>
        </div>
    </div>

    <div class="modal-mask" id="resultOverlay">
        <div class="result-text" id="resultText">èƒœåˆ©</div>
        <button class="restart-btn" onclick="initGame()">å†æˆ˜æ±Ÿæ¹–</button>
    </div>

<script>
    // æ³¨æ„ï¼šCanvas å†…éƒ¨ç”± 450 æ”¹ä¸º 900 ä»¥æ”¯æŒé«˜æ¸…å±ï¼Œé€»è¾‘åæ ‡éœ€è½¬æ¢
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');
    const effCanvas = document.getElementById('effectLayer');
    const effCtx = effCanvas.getContext('2d');
    const logBox = document.getElementById('combat-log');
    
    const GRID = 15;
    const CANVAS_SIZE = 900; // å†…éƒ¨é«˜åˆ†è¾¨ç‡
    const CELL = CANVAS_SIZE / GRID; // 60px
    const PADDING = CELL / 2; // 30px

    let board = [], turn = 1, turnCount = 1, mp = { 1: 30, 2: 30 };
    let gameOver = false, history = [], currentSkill = null, moveSource = null;
    const MP_REGEN_PLAYER = 5, MP_REGEN_AI = 8;
    const COSTS = { 1: 30, 2: 70, 3: 85, 4: 55, 5: 100 };

    function initGame(keepMP = false) {
        board = Array(GRID).fill().map(() => Array(GRID).fill(0));
        history = []; turn = 1; turnCount = 1;
        if (!keepMP) mp = { 1: 30, 2: 30 };
        gameOver = false; currentSkill = null; moveSource = null;
        document.getElementById('resultOverlay').style.display = 'none';
        logBox.innerHTML = '<div class="log-entry"><span class="log-sys">æˆ˜æ–—å¼€å§‹...</span></div>';
        updateStatus("è¯·ä¾ å®¢è½å­");
        drawBoard(); updateUI();
    }

    function updateStatus(msg, color="#ffd700") {
        const el = document.getElementById('status-text');
        el.innerText = msg; el.style.color = color;
    }

    function addLog(text, type='sys') {
        const div = document.createElement('div'); div.className = 'log-entry';
        let prefix = `<span class="log-turn">[T${turnCount}]</span> `;
        if(type==='p1') div.innerHTML = prefix + `<span class="log-p1">ä¾ å®¢</span> ${text}`;
        else if(type==='p2') div.innerHTML = prefix + `<span class="log-p2">é­”å¤´</span> ${text}`;
        else div.innerHTML = prefix + `<span class="log-sys">${text}</span>`;
        logBox.appendChild(div); logBox.scrollTop = logBox.scrollHeight;
    }

    // --- ç»˜å›¾ (é€‚é…é«˜åˆ†å±) ---
    function drawBoard() {
        ctx.fillStyle = "#eebb77"; ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
        ctx.beginPath(); ctx.strokeStyle = "#594f43"; ctx.lineWidth = 2; // çº¿æ¡åŠ ç²—
        for(let i=0; i<GRID; i++){
            ctx.moveTo(PADDING+i*CELL, PADDING); ctx.lineTo(PADDING+i*CELL, PADDING+(GRID-1)*CELL);
            ctx.moveTo(PADDING, PADDING+i*CELL); ctx.lineTo(PADDING+(GRID-1)*CELL, PADDING+i*CELL);
        }
        ctx.stroke();
        [3,7,11].forEach(r=>[3,7,11].forEach(c=>{
            ctx.beginPath(); ctx.arc(PADDING+c*CELL, PADDING+r*CELL, 6, 0, 2*Math.PI); ctx.fillStyle="#2c3e50"; ctx.fill();
        }));
        for(let r=0; r<GRID; r++) for(let c=0; c<GRID; c++) if(board[r][c] !== 0) drawPiece(r, c, board[r][c]);
        
        if(moveSource) {
            ctx.beginPath(); ctx.arc(PADDING+moveSource.c*CELL, PADDING+moveSource.r*CELL, 28, 0, 2*Math.PI);
            ctx.strokeStyle="#00C0FF"; ctx.lineWidth=6; ctx.stroke();
        }
        if(history.length > 0) {
            let last = history[history.length-1];
            ctx.fillStyle = "red"; ctx.beginPath(); ctx.arc(PADDING+last.c*CELL, PADDING+last.r*CELL, 6, 0, 2*Math.PI); ctx.fill();
        }
    }

    function drawPiece(r, c, type) {
        const x = PADDING + c*CELL, y = PADDING + r*CELL;
        ctx.beginPath(); ctx.arc(x, y, 26, 0, 2*Math.PI); // æ£‹å­åŠå¾„æ”¾å¤§
        const grad = ctx.createRadialGradient(x-10, y-10, 5, x, y, 26);
        if(type===1){ grad.addColorStop(0,"#444"); grad.addColorStop(1,"#000"); }
        else { grad.addColorStop(0,"#fff"); grad.addColorStop(1,"#ddd"); }
        ctx.fillStyle = grad; ctx.fill();
    }

    // --- äº¤äº’æ ¸å¿ƒä¿®å¤ ---
    canvas.addEventListener('click', e => {
        if(gameOver || turn !== 1) return;
        
        // è·å– Canvas åœ¨å±å¹•ä¸Šçš„å®é™…æ˜¾ç¤ºçŸ©å½¢
        const rect = canvas.getBoundingClientRect();
        
        // è®¡ç®—ç¼©æ”¾æ¯”ï¼šCanvas å†…éƒ¨å®½åº¦ (900) / å®é™…æ˜¾ç¤ºå®½åº¦
        const scaleX = CANVAS_SIZE / rect.width;
        const scaleY = CANVAS_SIZE / rect.height;
        
        // è½¬æ¢åæ ‡
        const x = (e.clientX - rect.left) * scaleX;
        const y = (e.clientY - rect.top) * scaleY;
        
        const c = Math.round((x - PADDING) / CELL);
        const r = Math.round((y - PADDING) / CELL);
        
        if(r<0||r>=GRID||c<0||c>=GRID) return;

        // æŠ€èƒ½é€»è¾‘
        if(currentSkill) {
            if(currentSkill === 2) {
                if(!moveSource) {
                    if(board[r][c] === 2) { moveSource = {r,c}; updateStatus("é€‰æ‹©ç›®æ ‡ç©ºä½"); drawBoard(); } 
                    else updateStatus("åªèƒ½é€‰ç™½å­", "#FF4757");
                } else {
                    if(board[r][c] === 0) {
                        mp[1] -= COSTS[2]; board[moveSource.r][moveSource.c] = 0; board[r][c] = 2;
                        history = []; addLog(`æ–½æ”¾ <span class="log-skill">é£æ²™èµ°çŸ³</span>`, 'p1');
                        playVisualEffect(2, moveSource.r, moveSource.c, r, c);
                        currentSkill = null; moveSource = null; drawBoard(); updateUI();
                        if(checkWin(r, c, 2)) endGame(2); else nextTurn();
                    } else updateStatus("å¿…é¡»æ˜¯ç©ºä½", "#FF4757");
                } return;
            }
            if(currentSkill === 4) {
                mp[1] -= COSTS[4];
                [[0,0],[0,1],[0,-1],[1,0],[-1,0]].forEach(([dr,dc]) => { let nr=r+dr, nc=c+dc; if(nr>=0&&nr<GRID&&nc>=0&&nc<GRID) board[nr][nc] = 0; });
                history = []; addLog(`æ–½æ”¾ <span class="log-skill">åŠ›æ‹”å±±å…®</span>`, 'p1');
                playVisualEffect(4, r, c); currentSkill = null; drawBoard(); updateUI(); nextTurn(); return;
            }
        }
        // æ™®é€šè½å­
        if(board[r][c] === 0) {
            board[r][c] = 1; history.push({r,c,p:1}); drawBoard(); addLog(`è½å­ (${r+1},${c+1})`, 'p1');
            if(checkWin(r, c, 1)) { endGame(1); return; } nextTurn();
        }
    });

    // --- æŠ€èƒ½ ---
    window.useSkill = function(id) {
        if(turn !== 1 || gameOver) return;
        if(mp[1] < COSTS[id]) { updateStatus("å†…åŠ›ä¸è¶³ï¼", "#FF4757"); return; }
        if(currentSkill === id && !moveSource) { currentSkill = null; updateStatus("å–æ¶ˆæ–½æ³•"); updateUI(); return; }
        
        moveSource = null; 
        if(id === 1) { if(history.length < 2) { updateStatus("æ— æ£‹å¯æ‚”"); return; } mp[1] -= COSTS[1]; undo(); undo(); drawBoard(); updateUI(); addLog(`æ–½æ”¾ <span class="log-skill">æ—¶å…‰å€’æµ</span>`, 'p1'); playVisualEffect(1, 7, 7); return; }
        if(id === 3) { mp[1] -= COSTS[3]; updateUI(); updateStatus("é¢å¤–å›åˆï¼", "#00C0FF"); addLog(`æ–½æ”¾ <span class="log-skill">é™å¦‚æ­¢æ°´</span>`, 'p1'); playVisualEffect(3, 7, 7); return; }
        if(id === 5) { if(confirm("æ¶ˆè€—å…¨éƒ¨å†…åŠ›é‡ç½®ï¼Ÿ")) { mp[1] -= COSTS[5]; addLog(`æ–½æ”¾ <span class="log-skill">ä¸œå±±å†èµ·</span>`, 'p1'); playVisualEffect(5, 7, 7); setTimeout(() => initGame(true), 500); } return; }
        
        currentSkill = id; updateUI();
        if(id === 2) updateStatus("é€‰æ‹©ï¼šæ•Œæ–¹æ£‹å­ -> ç©ºä½");
        if(id === 4) updateStatus("é€‰æ‹©ï¼šçˆ†ç ´ä¸­å¿ƒç‚¹");
    }
    function undo() { if(history.length > 0) { let m = history.pop(); board[m.r][m.c] = 0; } }

    function nextTurn() {
        turn = turn === 1 ? 2 : 1; if(turn===1) turnCount++;
        mp[1] = Math.min(100, mp[1] + MP_REGEN_PLAYER); mp[2] = Math.min(100, mp[2] + MP_REGEN_AI);
        updateUI(); if(turn === 2) setTimeout(aiTurn, 500);
    }

    // --- AI ---
    function aiTurn() {
        updateStatus("é­”å¤´æ€è€ƒä¸­...");
        let aiThree = findOpenThree(board, 2);
        if (aiThree && mp[2] >= COSTS[3]) {
            addLog(`æ–½æ”¾ <span class="log-skill">é™å¦‚æ­¢æ°´</span> (ç»æ€)`, 'p2');
            mp[2] -= COSTS[3]; playVisualEffect(3, 7, 7);
            makeAiMove(aiThree.r, aiThree.c, false); turn = 2; setTimeout(aiTurn, 800); return;
        }
        let threat = findThreat(board, 1); 
        if (threat && threat.score >= 8000 && mp[2] >= COSTS[4]) {
            let canBlock = findForcedBlock(board, 1);
            if (!canBlock || mp[2] > 80) {
                addLog(`æ–½æ”¾ <span class="log-skill">åŠ›æ‹”å±±å…®</span> (è§£å›´)`, 'p2');
                mp[2] -= COSTS[4];
                [[0,0],[0,1],[0,-1],[1,0],[-1,0]].forEach(([dr,dc]) => { let nr=threat.r+dr, nc=threat.c+dc; if(nr>=0&&nr<GRID&&nc>=0&&nc<GRID) board[nr][nc] = 0; });
                history = []; playVisualEffect(4, threat.r, threat.c);
                drawBoard(); updateUI();
                turn = 1; turnCount++; mp[1] = Math.min(100, mp[1] + MP_REGEN_PLAYER); updateUI();
                return;
            }
        }
        let killMove = solveVCF(board, 2, 15); if (killMove) { makeAiMove(killMove.r, killMove.c); return; }
        let defendMove = solveVCF(board, 1, 8); if (defendMove) { makeAiMove(defendMove.r, defendMove.c); return; }
        let best = getBestMove(); makeAiMove(best.r, best.c);
    }
    function makeAiMove(r, c, changeTurn = true) {
        board[r][c] = 2; history.push({r,c,p:2}); drawBoard(); addLog(`è½å­ (${r+1},${c+1})`, 'p2');
        if(checkWin(r, c, 2)) endGame(2);
        else if (changeTurn) { turn = 1; turnCount++; mp[1] = Math.min(100, mp[1] + MP_REGEN_PLAYER); updateUI(); updateStatus("è¯·ä¾ å®¢è½å­"); }
    }

    // AI Utils
    function findOpenThree(bd, p) { for(let r=0; r<GRID; r++) for(let c=0; c<GRID; c++) { if(bd[r][c]===0 && evaluatePoint(bd,r,c,p) >= 3000) return {r,c}; } return null; }
    function findThreat(bd, p) {
        let m=0,t=null; for(let r=0;r<GRID;r++)for(let c=0;c<GRID;c++) if(bd[r][c]===0){ bd[r][c]=p; let s=evaluatePoint(bd,r,c,p); bd[r][c]=0; if(s>m){m=s;t={r,c,score:s};} } 
        if(m>=8000){ 
            let target = null;
            for(let i=-2;i<=2;i++)for(let j=-2;j<=2;j++){ let nr=t.r+i, nc=t.c+j; if(nr>=0&&nr<GRID&&nc>=0&&nc<GRID&&bd[nr][nc]===p) { target={r:nr,c:nc}; break;} }
            return target ? {r:target.r,c:target.c,score:m} : t;
        } return null;
    }
    function solveVCF(bd,p,d) { if(d<=0)return null; let ms=findFourMoves(bd,p); for(let m of ms){ bd[m.r][m.c]=p; if(checkWinSimple(bd,m.r,m.c,p)){bd[m.r][m.c]=0;return m;} let b=findForcedBlock(bd,p); if(b){bd[b.r][b.c]=(p===1?2:1);let n=solveVCF(bd,p,d-1);bd[b.r][b.c]=0;bd[m.r][m.c]=0;if(n)return m;} else{bd[m.r][m.c]=0;return m;} bd[m.r][m.c]=0; } return null; }
    function findFourMoves(bd,p) { let ms=[]; for(let r=0;r<GRID;r++)for(let c=0;c<GRID;c++)if(bd[r][c]===0&&evaluatePoint(bd,r,c,p)>=10000)ms.push({r,c}); return ms;}
    function findForcedBlock(bd,atk) { for(let r=0;r<GRID;r++)for(let c=0;c<GRID;c++)if(bd[r][c]===0) { bd[r][c]=atk; let w=checkWinSimple(bd,r,c,atk); bd[r][c]=0; if(w) return {r,c}; } return null; }
    function getBestMove() { let b=null,m=-Infinity; for(let r=0;r<GRID;r++)for(let c=0;c<GRID;c++)if(board[r][c]===0) { let s=evaluatePoint(board,r,c,2)+evaluatePoint(board,r,c,1)*1.2; if(s>m){m=s;b={r,c};} } if(!b)b={r:7,c:7}; return b; }
    function evaluatePoint(bd,r,c,p) { let s=0; const ds=[[1,0],[0,1],[1,1],[1,-1]]; for(let [dr,dc] of ds){ let k=1,e=0,i=1; while(bd[r+i*dr]?.[c+i*dc]===p){k++;i++} if(bd[r+i*dr]?.[c+i*dc]===0)e++; i=1; while(bd[r-i*dr]?.[c-i*dc]===p){k++;i++} if(bd[r-i*dr]?.[c-i*dc]===0)e++; if(k>=5)s+=100000;else if(k==4)s+=(e==2?10000:2000);else if(k==3)s+=(e==2?1000:100);else if(k==2&&e==2)s+=50; } return s; }
    function checkWin(r,c,p){return checkWinSimple(board,r,c,p);}
    function checkWinSimple(bd,r,c,p){ const ds=[[1,0],[0,1],[1,1],[1,-1]]; for(let [dr,dc] of ds){ let k=1,i=1; while(bd[r+i*dr]?.[c+i*dc]===p){k++;i++} i=1; while(bd[r-i*dr]?.[c-i*dc]===p){k++;i++} if(k>=5)return true; } return false; }
    function endGame(w) {
        gameOver=true; const mask=document.getElementById('resultOverlay'); const txt=document.getElementById('resultText');
        mask.style.display='flex'; txt.innerText=w===1?"èƒœå¤©åŠå­":"èƒœè´¥å…µå®¶"; txt.style.color=w===1?"#ffd700":"#aaa";
        addLog(`æˆ˜æ–—ç»“æŸï¼š${w===1?'ä¾ å®¢èƒœåˆ©':'é­”å¤´èƒœåˆ©'}`, 'sys');
    }
    function updateUI() {
        document.getElementById('p1-mp').style.width=mp[1]+"%"; document.getElementById('p1-val').innerText=Math.floor(mp[1]);
        document.getElementById('p2-mp').style.width=mp[2]+"%"; document.getElementById('p2-val').innerText=Math.floor(mp[2]);
        for(let i=1;i<=5;i++){ let b=document.getElementById('btn-s'+i); b.className="skill-btn"; if(mp[1]>=COSTS[i]) b.classList.add('ready'); if(currentSkill===i) b.classList.add('active'); }
    }
    function playVisualEffect(skillId, r, c, tr=0, tc=0) {
        const x = PADDING + c*CELL, y = PADDING + r*CELL; effCtx.clearRect(0,0,CANVAS_SIZE,CANVAS_SIZE);
        if (skillId === 1) { let angle = 0; const loop = () => { effCtx.clearRect(0,0,CANVAS_SIZE,CANVAS_SIZE); effCtx.save(); effCtx.translate(CANVAS_SIZE/2, CANVAS_SIZE/2); effCtx.rotate(angle); for(let i=0; i<10; i++) { effCtx.beginPath(); effCtx.arc(i*30, 0, 10+i, 0, Math.PI*2); effCtx.fillStyle = `rgba(155, 89, 182, ${1-i/10})`; effCtx.fill(); } effCtx.restore(); angle -= 0.2; if(angle > -6) requestAnimationFrame(loop); else effCtx.clearRect(0,0,CANVAS_SIZE,CANVAS_SIZE); }; loop(); }
        else if (skillId === 2) { const tx = PADDING + tc*CELL, ty = PADDING + tr*CELL; let cx = x, cy = y, steps = 20, cur = 0; const dx = (tx-x)/steps, dy = (ty-y)/steps; const loop = () => { effCtx.clearRect(0,0,CANVAS_SIZE,CANVAS_SIZE); effCtx.beginPath(); effCtx.moveTo(x,y); effCtx.lineTo(cx,cy); effCtx.strokeStyle = "#e67e22"; effCtx.lineWidth = 6; effCtx.stroke(); effCtx.beginPath(); effCtx.arc(cx, cy, 16, 0, Math.PI*2); effCtx.fillStyle = "#d35400"; effCtx.fill(); cx += dx; cy += dy; cur++; if(cur <= steps) requestAnimationFrame(loop); else { effCtx.clearRect(0,0,CANVAS_SIZE,CANVAS_SIZE); effCtx.beginPath(); effCtx.arc(tx, ty, 40, 0, Math.PI*2); effCtx.fillStyle = "rgba(230, 126, 34, 0.5)"; effCtx.fill(); setTimeout(()=>effCtx.clearRect(0,0,CANVAS_SIZE,CANVAS_SIZE), 200); } }; loop(); }
        else if (skillId === 3) { effCtx.fillStyle = "rgba(0, 192, 255, 0.3)"; effCtx.fillRect(0,0,CANVAS_SIZE,CANVAS_SIZE); setTimeout(()=>effCtx.clearRect(0,0,CANVAS_SIZE,CANVAS_SIZE), 300); }
        else if (skillId === 4) { let r1 = 0; const loop = () => { effCtx.clearRect(0,0,CANVAS_SIZE,CANVAS_SIZE); effCtx.beginPath(); effCtx.arc(x, y, r1, 0, Math.PI*2); effCtx.fillStyle = `rgba(255, 71, 87, ${1-r1/120})`; effCtx.fill(); r1 += 8; if(r1 < 120) requestAnimationFrame(loop); else effCtx.clearRect(0,0,CANVAS_SIZE,CANVAS_SIZE); }; loop(); }
        else if (skillId === 5) { let alpha = 0, up = true; const loop = () => { effCtx.clearRect(0,0,CANVAS_SIZE,CANVAS_SIZE); effCtx.fillStyle = `rgba(255, 215, 0, ${alpha})`; effCtx.fillRect(0,0,CANVAS_SIZE,CANVAS_SIZE); if(up) { alpha+=0.05; if(alpha>=0.8) up=false; } else { alpha-=0.05; } if(alpha > 0) requestAnimationFrame(loop); }; loop(); }
    }
    function toggleHelp() { const modal = document.getElementById('helpModal'); modal.style.display = (modal.style.display === 'flex') ? 'none' : 'flex'; }
    initGame();
</script>
</body>
</html>