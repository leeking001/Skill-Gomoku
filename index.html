<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>äº”å­æ£‹ï¼šè¯¸ç¥ä¹‹æˆ˜</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&display=swap" rel="stylesheet">
    <style>
        :root {
            --wow-gold: #F8B700;
            --wow-dark: #0F1115;
            --wow-panel: #181A21;
            --wow-border: #565656;
            --log-bg: rgba(0, 0, 0, 0.6);
            /* åŠ¨æ€è®¡ç®—åº•éƒ¨å®‰å…¨åŒºï¼Œé»˜è®¤ä¸º 20px */
            --safe-bottom: env(safe-area-inset-bottom, 20px);
        }

        body {
            font-family: "KaiTi", "STKaiti", serif;
            background-color: #050505;
            color: #eee;
            display: flex; flex-direction: column; align-items: center;
            margin: 0; height: 100vh; overflow: hidden; user-select: none;
            background-image: radial-gradient(circle at 50% 30%, #2a2a2a 0%, #000 80%);
        }

        /* --- é¡¶éƒ¨åŒºåŸŸ --- */
        .header-area {
            display: flex; align-items: center; width: 92%; justify-content: center;
            position: relative; margin-top: 10px; flex-shrink: 0;
        }
        h1 { font-size: 24px; margin: 0; text-shadow: 0 0 10px #ff4757; letter-spacing: 3px; color: #eccc68; }
        .help-btn {
            position: absolute; right: 0; font-size: 12px; padding: 4px 10px;
            border: 1px solid #666; border-radius: 12px; color: #aaa;
            background: rgba(0,0,0,0.5);
        }

        /* --- AI é¢æ¿ --- */
        .boss-frame {
            width: 92%; display: flex; align-items: center; margin-top: 8px; padding: 6px;
            background: var(--wow-panel); border: 2px solid #8C1616; border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.8); flex-shrink: 0;
        }
        .portrait {
            width: 40px; height: 40px; background: #000; border: 2px solid var(--wow-gold);
            border-radius: 4px; display: flex; align-items: center; justify-content: center;
            font-size: 22px; margin-right: 10px; flex-shrink: 0;
        }
        .stats { flex: 1; }
        .name { font-size: 14px; color: var(--wow-gold); font-weight: bold; text-shadow: 1px 1px 0 #000; }
        .bar-container { height: 8px; background: #111; border: 1px solid #333; margin-top: 3px; position: relative; }
        .bar-fill { height: 100%; width: 0%; transition: width 0.4s ease-out; }
        .mana { background: linear-gradient(90deg, #0070DE, #00C0FF); }
        .rage { background: linear-gradient(90deg, #8C1616, #FF4757); }
        .bar-text { position: absolute; top: -2px; width: 100%; text-align: center; font-size: 9px; color: #fff; text-shadow: 1px 1px 0 #000; transform: scale(0.9); font-family: sans-serif; }

        /* --- æ£‹ç›˜åŒºåŸŸ (æ ¸å¿ƒ) --- */
        .board-wrapper {
            margin: 5px 0; padding: 4px; background: #252525;
            border: 3px solid var(--wow-gold); border-radius: 4px;
            box-shadow: 0 10px 30px rgba(0,0,0,1);
            /* ç§»é™¤ flex-shrink é˜²æ­¢æ£‹ç›˜è¢«æŒ¤å‹å˜å½¢ï¼Œæ”¹ç”¨ JS ç¼©æ”¾ */
            flex-shrink: 0; 
            transform-origin: center center;
        }
        canvas { display: block; cursor: crosshair; }
        #effectLayer { position: absolute; top: 4px; left: 4px; pointer-events: none; z-index: 2; }

        /* --- æˆ˜æ–—æ—¥å¿— --- */
        .combat-log-container {
            width: 92%; height: 0; flex-grow: 1; /* è‡ªåŠ¨å¡«å……å‰©ä½™ç©ºé—´ï¼Œæœ€å°‘æ˜¾ç¤ºä¸€ç‚¹ */
            min-height: 40px; max-height: 100px;
            background: var(--log-bg); border: 1px solid #444; border-radius: 4px;
            margin-bottom: 5px; overflow-y: auto; padding: 4px;
            font-family: sans-serif; font-size: 10px; line-height: 14px;
            box-shadow: inset 0 0 10px #000; scroll-behavior: smooth;
            flex-shrink: 1;
        }
        .log-entry { margin-bottom: 2px; }
        .log-p1 { color: #4cd137; } .log-p2 { color: #FF4757; } .log-skill { color: var(--wow-gold); } .log-sys { color: #aaa; }

        /* --- åº•éƒ¨ç©å®¶æ“ä½œåŒº --- */
        .player-zone {
            width: 100%;
            display: flex; flex-direction: column; align-items: center;
            background: linear-gradient(to top, #111 0%, rgba(20,20,20,0.9) 100%);
            padding-bottom: calc(5px + var(--safe-bottom)); /* é€‚é… iPhone å°é»‘æ¡ */
            border-top: 1px solid #333;
            flex-shrink: 0;
        }
        
        /* çŠ¶æ€æç¤º (ä¸å†æ‚¬æµ®) */
        .status-text {
            font-size: 14px; color: #ffd700; text-shadow: 1px 1px 2px #000;
            margin: 5px 0; height: 20px; line-height: 20px; text-align: center;
        }

        .player-frame {
            width: 92%; display: flex; align-items: center; flex-direction: row-reverse;
            padding: 6px; margin-bottom: 8px;
            background: var(--wow-panel); border: 2px solid #4cd137; border-radius: 4px;
        }
        .player-frame .name { text-align: right; color: #4cd137; }

        /* æŠ€èƒ½æ  */
        .action-bar { display: grid; grid-template-columns: repeat(5, 1fr); gap: 8px; padding: 0 10px; width: 92%; box-sizing: border-box; }
        .skill-btn {
            aspect-ratio: 1/1; /* ä¿æŒæ­£æ–¹å½¢ */
            background: #222; border: 1px solid #666; border-radius: 4px;
            position: relative; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center;
            box-shadow: inset 0 0 5px #000; transition: 0.1s;
        }
        .skill-icon-text { font-size: 18px; margin-bottom: 2px; }
        .skill-name { font-size: 9px; color: #ddd; transform: scale(0.8); white-space: nowrap; }
        .cost-badge {
            position: absolute; top: -3px; right: -3px; font-family: sans-serif; font-size: 9px; color: #fff;
            background: rgba(0,0,0,0.8); padding: 1px 3px; border-radius: 3px; border: 1px solid #444;
        }
        
        .skill-btn:not(.ready) { filter: grayscale(100%) brightness(0.5); }
        .skill-btn.ready { border-color: #aaa; box-shadow: 0 0 5px var(--wow-gold); }
        .skill-btn.active { border-color: #FF4757; box-shadow: 0 0 10px #FF4757; animation: flash 1s infinite; }
        @keyframes flash { 0%,100% { border-color: #FF4757; } 50% { border-color: #fff; } }

        /* å¼¹çª—ä¸é®ç½© */
        .modal-mask { position: fixed; top:0; left:0; width:100%; height:100%; background: rgba(0,0,0,0.9); z-index: 999; display: none; align-items: center; justify-content: center; flex-direction: column; }
        .result-text { font-size: 50px; color: var(--wow-gold); text-shadow: 0 0 20px #e67e22; font-weight: bold; animation: scaleIn 0.5s; margin-bottom: 30px; }
        .restart-btn { padding: 10px 30px; background: #8C1616; color: #fff; border: 2px solid #fff; font-size: 16px; border-radius: 4px; font-family: 'KaiTi'; }
        @keyframes scaleIn { from {transform: scale(0);} to {transform: scale(1);} }
        
        /* è¯´æ˜ä¹¦ */
        .help-content { width: 80%; background: #181818; border: 1px solid #666; padding: 20px; border-radius: 8px; color: #ddd; font-size: 12px; line-height: 1.6; }
        .help-row { display: flex; justify-content: space-between; border-bottom: 1px solid #333; padding: 5px 0; }

    </style>
</head>
<body>

    <div class="header-area">
        <h1>è¯¸ç¥ä¹‹æˆ˜</h1>
        <div class="help-btn" onclick="toggleHelp()">æŠ€èƒ½è¯´æ˜</div>
    </div>

    <div class="boss-frame">
        <div class="portrait">ğŸ‘¹</div>
        <div class="stats">
            <div class="name">é­”å¤´ (AI)</div>
            <div class="bar-container"><div class="bar-fill rage" id="p2-mp"></div><div class="bar-text"><span id="p2-val">0</span> / 100</div></div>
        </div>
    </div>

    <div class="board-wrapper" id="board-wrapper">
        <canvas id="board" width="450" height="450"></canvas>
        <canvas id="effectLayer" width="450" height="450"></canvas>
    </div>

    <div class="combat-log-container" id="combat-log">
        <div class="log-entry"><span class="log-sys">æˆ˜æ–—å¼€å§‹...</span></div>
    </div>

    <div class="player-zone">
        <div class="status-text" id="status-text">è¯·ä¾ å®¢è½å­</div>

        <div class="player-frame">
            <div class="portrait">ğŸ¥·</div>
            <div class="stats">
                <div class="name">ä¾ å®¢ (ä½ )</div>
                <div class="bar-container"><div class="bar-fill mana" id="p1-mp"></div><div class="bar-text"><span id="p1-val">0</span> / 100</div></div>
            </div>
        </div>

        <div class="action-bar">
            <div class="skill-btn" id="btn-s1" onclick="useSkill(1)"><div class="cost-badge">30</div><div class="skill-icon-text">â³</div><div class="skill-name">æ—¶å…‰å€’æµ</div></div>
            <div class="skill-btn" id="btn-s2" onclick="useSkill(2)"><div class="cost-badge">70</div><div class="skill-icon-text">ğŸŒªï¸</div><div class="skill-name">é£æ²™èµ°çŸ³</div></div>
            <div class="skill-btn" id="btn-s3" onclick="useSkill(3)"><div class="cost-badge">85</div><div class="skill-icon-text">ğŸ§Š</div><div class="skill-name">é™å¦‚æ­¢æ°´</div></div>
            <div class="skill-btn" id="btn-s4" onclick="useSkill(4)"><div class="cost-badge">55</div><div class="skill-icon-text">ğŸ’¥</div><div class="skill-name">åŠ›æ‹”å±±å…®</div></div>
            <div class="skill-btn" id="btn-s5" onclick="useSkill(5)"><div class="cost-badge">100</div><div class="skill-icon-text">â™»ï¸</div><div class="skill-name">ä¸œå±±å†èµ·</div></div>
        </div>
    </div>

    <div class="modal-mask" id="helpModal" onclick="toggleHelp()">
        <div class="help-content" onclick="event.stopPropagation()">
            <h3 style="color:#eccc68; margin-top:0; text-align:center">æŠ€èƒ½æ‰‹å†Œ</h3>
            <div class="help-row"><span style="color:#9b59b6">æ—¶å…‰å€’æµ (30)</span><span>æ‚”æ£‹ä¸€æ­¥</span></div>
            <div class="help-row"><span style="color:#e74c3c">åŠ›æ‹”å±±å…® (55)</span><span>ç‚¸æ¯åå­—èŒƒå›´</span></div>
            <div class="help-row"><span style="color:#e67e22">é£æ²™èµ°çŸ³ (70)</span><span>ç§»åŠ¨æ•Œå­</span></div>
            <div class="help-row"><span style="color:#3498db">é™å¦‚æ­¢æ°´ (85)</span><span>é¢å¤–å›åˆ</span></div>
            <div class="help-row"><span style="color:#f1c40f">ä¸œå±±å†èµ· (100)</span><span>é‡ç½®æ£‹å±€</span></div>
            <p style="color:#aaa; text-align:center; margin-bottom:0">ç‚¹å‡»ä»»æ„å¤„å…³é—­</p>
        </div>
    </div>

    <div class="modal-mask" id="resultOverlay">
        <div class="result-text" id="resultText">èƒœåˆ©</div>
        <button class="restart-btn" onclick="initGame()">å†æˆ˜æ±Ÿæ¹–</button>
    </div>

<script>
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');
    const effCanvas = document.getElementById('effectLayer');
    const effCtx = effCanvas.getContext('2d');
    const logBox = document.getElementById('combat-log');
    
    const GRID = 15, CELL = 30, PADDING = 15;
    let board = [], turn = 1, turnCount = 1, mp = { 1: 30, 2: 30 };
    let gameOver = false, history = [], currentSkill = null, moveSource = null;
    const MP_REGEN_PLAYER = 5, MP_REGEN_AI = 8;
    const COSTS = { 1: 30, 2: 70, 3: 85, 4: 55, 5: 100 };

    // --- æ™ºèƒ½å±å¹•é€‚é… ---
    function resizeBoard() {
        const wrapper = document.getElementById('board-wrapper');
        const headerH = document.querySelector('.header-area').offsetHeight;
        const bossH = document.querySelector('.boss-frame').offsetHeight;
        const playerH = document.querySelector('.player-zone').offsetHeight;
        const screenW = window.innerWidth;
        const screenH = window.innerHeight;
        
        // è®¡ç®—ç•™ç»™æ£‹ç›˜çš„æœ€å¤§é«˜åº¦
        const availableH = screenH - headerH - bossH - playerH - 40; // 40px buffer
        const baseSize = 464; // æ£‹ç›˜ CSS å®½åº¦ (450+borders)

        // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹ï¼šå– å®½åº¦ç¼©æ”¾ å’Œ é«˜åº¦ç¼©æ”¾ çš„è¾ƒå°å€¼
        let scale = Math.min(
            (screenW - 20) / baseSize, // å®½åº¦é™åˆ¶
            availableH / baseSize      // é«˜åº¦é™åˆ¶
        );
        
        if (scale < 1) {
            wrapper.style.transform = `scale(${scale})`;
            // è°ƒæ•´ margin ä»¥æ¶ˆé™¤ç¼©æ”¾äº§ç”Ÿçš„ç©ºç™½
            const marginY = (1 - scale) * baseSize / 2;
            wrapper.style.marginTop = `-${marginY}px`;
            wrapper.style.marginBottom = `-${marginY}px`;
        } else {
            wrapper.style.transform = 'scale(1)';
            wrapper.style.marginTop = '5px';
            wrapper.style.marginBottom = '5px';
        }
    }
    window.addEventListener('resize', resizeBoard);
    // åˆå§‹åŒ–æ—¶å»¶æ—¶æ‰§è¡Œï¼Œç¡®ä¿ DOM æ¸²æŸ“å®Œæ¯•
    setTimeout(resizeBoard, 100);

    // --- æ¸¸æˆé€»è¾‘ ---
    function initGame(keepMP = false) {
        board = Array(GRID).fill().map(() => Array(GRID).fill(0));
        history = []; turn = 1; turnCount = 1;
        if (!keepMP) mp = { 1: 30, 2: 30 };
        gameOver = false; currentSkill = null; moveSource = null;
        document.getElementById('resultOverlay').style.display = 'none';
        logBox.innerHTML = '<div class="log-entry"><span class="log-sys">æˆ˜æ–—å¼€å§‹...</span></div>';
        updateStatus("è¯·ä¾ å®¢è½å­");
        drawBoard(); updateUI();
    }

    function updateStatus(msg, color="#ffd700") {
        const el = document.getElementById('status-text');
        el.innerText = msg; el.style.color = color;
    }

    function addLog(text, type='sys') {
        const div = document.createElement('div'); div.className = 'log-entry';
        let prefix = `<span class="log-turn">[T${turnCount}]</span> `;
        if(type==='p1') div.innerHTML = prefix + `<span class="log-p1">ä¾ å®¢</span> ${text}`;
        else if(type==='p2') div.innerHTML = prefix + `<span class="log-p2">é­”å¤´</span> ${text}`;
        else div.innerHTML = prefix + `<span class="log-sys">${text}</span>`;
        logBox.appendChild(div); logBox.scrollTop = logBox.scrollHeight;
    }

    // --- ç»˜å›¾ ---
    function drawBoard() {
        ctx.fillStyle = "#eebb77"; ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.beginPath(); ctx.strokeStyle = "#594f43"; ctx.lineWidth = 1;
        for(let i=0; i<GRID; i++){ ctx.moveTo(PADDING+i*CELL, PADDING); ctx.lineTo(PADDING+i*CELL, PADDING+(GRID-1)*CELL); ctx.moveTo(PADDING, PADDING+i*CELL); ctx.lineTo(PADDING+(GRID-1)*CELL, PADDING+i*CELL); } ctx.stroke();
        [3,7,11].forEach(r=>[3,7,11].forEach(c=>{ ctx.beginPath(); ctx.arc(PADDING+c*CELL, PADDING+r*CELL, 3, 0, 2*Math.PI); ctx.fillStyle="#2c3e50"; ctx.fill(); }));
        for(let r=0; r<GRID; r++) for(let c=0; c<GRID; c++) if(board[r][c] !== 0) drawPiece(r, c, board[r][c]);
        if(moveSource) { ctx.beginPath(); ctx.arc(PADDING+moveSource.c*CELL, PADDING+moveSource.r*CELL, 15, 0, 2*Math.PI); ctx.strokeStyle="#00C0FF"; ctx.lineWidth=3; ctx.stroke(); }
        if(history.length > 0) { let last = history[history.length-1]; ctx.fillStyle = "red"; ctx.beginPath(); ctx.arc(PADDING+last.c*CELL, PADDING+last.r*CELL, 3, 0, 2*Math.PI); ctx.fill(); }
    }
    function drawPiece(r, c, type) {
        const x = PADDING + c*CELL, y = PADDING + r*CELL; ctx.beginPath(); ctx.arc(x, y, 13, 0, 2*Math.PI);
        const grad = ctx.createRadialGradient(x-3, y-3, 2, x, y, 13);
        if(type===1){ grad.addColorStop(0,"#333"); grad.addColorStop(1,"#000"); } else { grad.addColorStop(0,"#fff"); grad.addColorStop(1,"#ddd"); }
        ctx.fillStyle = grad; ctx.fill();
    }

    // --- æŠ€èƒ½ ---
    window.useSkill = function(id) {
        if(turn !== 1 || gameOver) return;
        if(mp[1] < COSTS[id]) { updateStatus("å†…åŠ›ä¸è¶³ï¼", "#FF4757"); return; }
        if(currentSkill === id && !moveSource) { currentSkill = null; updateStatus("å–æ¶ˆæ–½æ³•"); updateUI(); return; }
        moveSource = null; 
        if(id === 1) { if(history.length < 2) { updateStatus("æ— æ£‹å¯æ‚”", "#FF4757"); return; } mp[1] -= COSTS[1]; undo(); undo(); drawBoard(); updateUI(); addLog(`æ–½æ”¾ <span class="log-skill">æ—¶å…‰å€’æµ</span>`, 'p1'); playVisualEffect(1, 7, 7); return; }
        if(id === 3) { mp[1] -= COSTS[3]; updateUI(); updateStatus("é¢å¤–å›åˆï¼", "#00C0FF"); addLog(`æ–½æ”¾ <span class="log-skill">é™å¦‚æ­¢æ°´</span>`, 'p1'); playVisualEffect(3, 7, 7); return; }
        if(id === 5) { if(confirm("æ¶ˆè€—å…¨éƒ¨å†…åŠ›é‡ç½®ï¼Ÿ")) { mp[1] -= COSTS[5]; addLog(`æ–½æ”¾ <span class="log-skill">ä¸œå±±å†èµ·</span>`, 'p1'); playVisualEffect(5, 7, 7); setTimeout(() => initGame(true), 500); } return; }
        currentSkill = id; updateUI();
        if(id === 2) updateStatus("é€‰æ‹©ï¼šæ•Œæ–¹æ£‹å­ -> ç©ºä½");
        if(id === 4) updateStatus("é€‰æ‹©ï¼šçˆ†ç ´ä¸­å¿ƒç‚¹");
    }
    function undo() { if(history.length > 0) { let m = history.pop(); board[m.r][m.c] = 0; } }

    canvas.addEventListener('click', e => {
        if(gameOver || turn !== 1) return;
        const rect = canvas.getBoundingClientRect();
        // è·å–å½“å‰çš„ç¼©æ”¾æ¯”ä¾‹
        const computedStyle = window.getComputedStyle(document.getElementById('board-wrapper'));
        const transform = computedStyle.getPropertyValue('transform');
        let scale = 1;
        if(transform && transform !== 'none') {
            const values = transform.split('(')[1].split(')')[0].split(',');
            scale = parseFloat(values[0]);
        }
        
        const c = Math.round(((e.clientX - rect.left) / scale - PADDING) / CELL);
        const r = Math.round(((e.clientY - rect.top) / scale - PADDING) / CELL);
        
        if(r<0||r>=GRID||c<0||c>=GRID) return;

        if(currentSkill) {
            if(currentSkill === 2) {
                if(!moveSource) {
                    if(board[r][c] === 2) { moveSource = {r,c}; updateStatus("é€‰æ‹©ç›®æ ‡ç©ºä½"); drawBoard(); } else updateStatus("åªèƒ½é€‰ç™½å­", "#FF4757");
                } else {
                    if(board[r][c] === 0) {
                        mp[1] -= COSTS[2]; board[moveSource.r][moveSource.c] = 0; board[r][c] = 2;
                        history = []; addLog(`æ–½æ”¾ <span class="log-skill">é£æ²™èµ°çŸ³</span>`, 'p1'); playVisualEffect(2, moveSource.r, moveSource.c, r, c);
                        currentSkill = null; moveSource = null; drawBoard(); updateUI();
                        if(checkWin(r, c, 2)) endGame(2); else nextTurn();
                    } else updateStatus("å¿…é¡»æ˜¯ç©ºä½", "#FF4757");
                } return;
            }
            if(currentSkill === 4) {
                mp[1] -= COSTS[4];
                [[0,0],[0,1],[0,-1],[1,0],[-1,0]].forEach(([dr,dc]) => { let nr=r+dr, nc=c+dc; if(nr>=0&&nr<GRID&&nc>=0&&nc<GRID) board[nr][nc] = 0; });
                history = []; addLog(`æ–½æ”¾ <span class="log-skill">åŠ›æ‹”å±±å…®</span>`, 'p1'); playVisualEffect(4, r, c);
                currentSkill = null; drawBoard(); updateUI(); nextTurn(); return;
            }
        }
        if(board[r][c] === 0) {
            board[r][c] = 1; history.push({r,c,p:1}); drawBoard(); addLog(`è½å­ (${r+1},${c+1})`, 'p1');
            if(checkWin(r, c, 1)) { endGame(1); return; } nextTurn();
        }
    });

    function nextTurn() {
        turn = turn === 1 ? 2 : 1; if(turn===1) turnCount++;
        mp[1] = Math.min(100, mp[1] + MP_REGEN_PLAYER); mp[2] = Math.min(100, mp[2] + MP_REGEN_AI);
        updateUI(); if(turn === 2) setTimeout(aiTurn, 500);
    }

    // --- AI V5.0 ---
    function aiTurn() {
        updateStatus("é­”å¤´æ€è€ƒä¸­...");
        let aiThree = findOpenThree(board, 2);
        if (aiThree && mp[2] >= COSTS[3]) {
            addLog(`æ–½æ”¾ <span class="log-skill">é™å¦‚æ­¢æ°´</span> (ç»æ€)`, 'p2');
            mp[2] -= COSTS[3]; playVisualEffect(3, 7, 7);
            makeAiMove(aiThree.r, aiThree.c, false); turn = 2; setTimeout(aiTurn, 800); return;
        }
        let threat = findThreat(board, 1); 
        if (threat && threat.score >= 8000 && mp[2] >= COSTS[4]) {
             // ç®€å•VCFé˜²å®ˆæ£€æŸ¥
            let canBlock = findForcedBlock(board, 1);
            if (!canBlock || mp[2] > 80) {
                addLog(`æ–½æ”¾ <span class="log-skill">åŠ›æ‹”å±±å…®</span> (è§£å›´)`, 'p2');
                mp[2] -= COSTS[4];
                [[0,0],[0,1],[0,-1],[1,0],[-1,0]].forEach(([dr,dc]) => {
                    let nr=threat.r+dr, nc=threat.c+dc; if(nr>=0&&nr<GRID&&nc>=0&&nc<GRID) board[nr][nc] = 0;
                });
                history = []; playVisualEffect(4, threat.r, threat.c);
                drawBoard(); updateUI();
                turn = 1; turnCount++; mp[1] = Math.min(100, mp[1] + MP_REGEN_PLAYER); updateUI();
                return;
            }
        }
        let killMove = solveVCF(board, 2, 15); if (killMove) { makeAiMove(killMove.r, killMove.c); return; }
        let defendMove = solveVCF(board, 1, 8); if (defendMove) { makeAiMove(defendMove.r, defendMove.c); return; }
        let best = getBestMove(); makeAiMove(best.r, best.c);
    }
    function makeAiMove(r, c, changeTurn = true) {
        board[r][c] = 2; history.push({r,c,p:2}); drawBoard(); addLog(`è½å­ (${r+1},${c+1})`, 'p2');
        if(checkWin(r, c, 2)) endGame(2);
        else if (changeTurn) { turn = 1; turnCount++; mp[1] = Math.min(100, mp[1] + MP_REGEN_PLAYER); updateUI(); updateStatus("è¯·ä¾ å®¢è½å­"); }
    }

    // è¾…åŠ©å‡½æ•° (AI, æ£€æŸ¥, ç‰¹æ•ˆ)
    function findOpenThree(bd, p) { for(let r=0; r<GRID; r++) for(let c=0; c<GRID; c++) { if(bd[r][c]===0 && evaluatePoint(bd,r,c,p) >= 3000) return {r,c}; } return null; }
    function findThreat(bd, p) {
        let m=0,t=null; for(let r=0;r<GRID;r++)for(let c=0;c<GRID;c++) if(bd[r][c]===0){
            bd[r][c]=p; let s=evaluatePoint(bd,r,c,p); bd[r][c]=0; if(s>m){m=s;t={r,c,score:s};}
        } 
        if(m>=8000){ 
            // å°è¯•æ‰¾å¨èƒæ£‹å­
            let target = null, maxChain = 0;
            for(let i=-2;i<=2;i++)for(let j=-2;j<=2;j++){
                let nr=t.r+i, nc=t.c+j;
                if(nr>=0&&nr<GRID&&nc>=0&&nc<GRID&&bd[nr][nc]===p) { target={r:nr,c:nc}; break;}
            }
            return target ? {r:target.r,c:target.c,score:m} : t;
        }
        return null;
    }
    function solveVCF(bd,p,d) { if(d<=0)return null; let ms=findFourMoves(bd,p); for(let m of ms){ bd[m.r][m.c]=p; if(checkWinSimple(bd,m.r,m.c,p)){bd[m.r][m.c]=0;return m;} let b=findForcedBlock(bd,p); if(b){bd[b.r][b.c]=(p===1?2:1);let n=solveVCF(bd,p,d-1);bd[b.r][b.c]=0;bd[m.r][m.c]=0;if(n)return m;} else{bd[m.r][m.c]=0;return m;} bd[m.r][m.c]=0; } return null; }
    function findFourMoves(bd,p) { let ms=[]; for(let r=0;r<GRID;r++)for(let c=0;c<GRID;c++)if(bd[r][c]===0&&evaluatePoint(bd,r,c,p)>=10000)ms.push({r,c}); return ms;}
    function findForcedBlock(bd,atk) { for(let r=0;r<GRID;r++)for(let c=0;c<GRID;c++)if(bd[r][c]===0){bd[r][c]=atk;let w=checkWinSimple(bd,r,c,atk);bd[r][c]=0;if(w)return{r,c};} return null;}
    function getBestMove() { let b=null,m=-Infinity; for(let r=0;r<GRID;r++)for(let c=0;c<GRID;c++)if(board[r][c]===0){ let s=evaluatePoint(board,r,c,2)+evaluatePoint(board,r,c,1)*1.2; if(s>m){m=s;b={r,c};} } if(!b)b={r:7,c:7}; return b; }
    function evaluatePoint(bd,r,c,p) { let s=0; const ds=[[1,0],[0,1],[1,1],[1,-1]]; for(let [dr,dc] of ds){ let k=1,e=0,i=1; while(bd[r+i*dr]?.[c+i*dc]===p){k++;i++} if(bd[r+i*dr]?.[c+i*dc]===0)e++; i=1; while(bd[r-i*dr]?.[c-i*dc]===p){k++;i++} if(bd[r-i*dr]?.[c-i*dc]===0)e++; if(k>=5)s+=100000;else if(k==4)s+=(e==2?10000:2000);else if(k==3)s+=(e==2?1000:100);else if(k==2&&e==2)s+=50; } return s; }
    function checkWin(r,c,p){return checkWinSimple(board,r,c,p);}
    function checkWinSimple(bd,r,c,p){ const ds=[[1,0],[0,1],[1,1],[1,-1]]; for(let [dr,dc] of ds){ let k=1,i=1; while(bd[r+i*dr]?.[c+i*dc]===p){k++;i++} i=1; while(bd[r-i*dr]?.[c-i*dc]===p){k++;i++} if(k>=5)return true; } return false; }
    
    function endGame(w) {
        gameOver=true; const mask=document.getElementById('resultOverlay'); const txt=document.getElementById('resultText');
        mask.style.display='flex'; txt.innerText=w===1?"èƒœå¤©åŠå­":"èƒœè´¥å…µå®¶"; txt.style.color=w===1?"#ffd700":"#aaa";
        addLog(`æˆ˜æ–—ç»“æŸï¼š${w===1?'ä¾ å®¢èƒœåˆ©':'é­”å¤´èƒœåˆ©'}`, 'sys');
    }
    function updateUI() {
        document.getElementById('p1-mp').style.width=mp[1]+"%"; document.getElementById('p1-val').innerText=Math.floor(mp[1]);
        document.getElementById('p2-mp').style.width=mp[2]+"%"; document.getElementById('p2-val').innerText=Math.floor(mp[2]);
        for(let i=1;i<=5;i++){ let b=document.getElementById('btn-s'+i); b.className="skill-btn"; if(mp[1]>=COSTS[i]) b.classList.add('ready'); if(currentSkill===i) b.classList.add('active'); }
    }
    function playVisualEffect(skillId, r, c, tr=0, tc=0) {
        const x = PADDING + c*CELL, y = PADDING + r*CELL; effCtx.clearRect(0,0,450,450);
        if (skillId === 1) { let angle = 0; const loop = () => { effCtx.clearRect(0,0,450,450); effCtx.save(); effCtx.translate(225, 225); effCtx.rotate(angle); for(let i=0; i<10; i++) { effCtx.beginPath(); effCtx.arc(i*15, 0, 5+i, 0, Math.PI*2); effCtx.fillStyle = `rgba(155, 89, 182, ${1-i/10})`; effCtx.fill(); } effCtx.restore(); angle -= 0.2; if(angle > -6) requestAnimationFrame(loop); else effCtx.clearRect(0,0,450,450); }; loop(); }
        else if (skillId === 2) { const tx = PADDING + tc*CELL, ty = PADDING + tr*CELL; let cx = x, cy = y, steps = 20, cur = 0; const dx = (tx-x)/steps, dy = (ty-y)/steps; const loop = () => { effCtx.clearRect(0,0,450,450); effCtx.beginPath(); effCtx.moveTo(x,y); effCtx.lineTo(cx,cy); effCtx.strokeStyle = "#e67e22"; effCtx.lineWidth = 3; effCtx.stroke(); effCtx.beginPath(); effCtx.arc(cx, cy, 8, 0, Math.PI*2); effCtx.fillStyle = "#d35400"; effCtx.fill(); cx += dx; cy += dy; cur++; if(cur <= steps) requestAnimationFrame(loop); else { effCtx.clearRect(0,0,450,450); effCtx.beginPath(); effCtx.arc(tx, ty, 20, 0, Math.PI*2); effCtx.fillStyle = "rgba(230, 126, 34, 0.5)"; effCtx.fill(); setTimeout(()=>effCtx.clearRect(0,0,450,450), 200); } }; loop(); }
        else if (skillId === 3) { effCtx.fillStyle = "rgba(0, 192, 255, 0.3)"; effCtx.fillRect(0,0,450,450); setTimeout(()=>effCtx.clearRect(0,0,450,450), 300); }
        else if (skillId === 4) { let r1 = 0; const loop = () => { effCtx.clearRect(0,0,450,450); effCtx.beginPath(); effCtx.arc(x, y, r1, 0, Math.PI*2); effCtx.fillStyle = `rgba(255, 71, 87, ${1-r1/60})`; effCtx.fill(); r1 += 4; if(r1 < 60) requestAnimationFrame(loop); else effCtx.clearRect(0,0,450,450); }; loop(); }
        else if (skillId === 5) { let alpha = 0, up = true; const loop = () => { effCtx.clearRect(0,0,450,450); effCtx.fillStyle = `rgba(255, 215, 0, ${alpha})`; effCtx.fillRect(0,0,450,450); if(up) { alpha+=0.05; if(alpha>=0.8) up=false; } else { alpha-=0.05; } if(alpha > 0) requestAnimationFrame(loop); }; loop(); }
    }

    function toggleHelp() {
        const modal = document.getElementById('helpModal');
        modal.style.display = (modal.style.display === 'flex') ? 'none' : 'flex';
    }
    initGame();
</script>
</body>
</html>